use super::{span, word, Parser, E, Push, Flush};

pub struct Bracket<T> {
    pub open: char,
    pub contents: T,
}

pub const MISSING_OPEN: E = "Missing open bracket";
pub const MISSING_CLOSE: E = "Missing close bracket";

// ----------------------------------------------------------------------------

/// A token type ignored by [`BracketParser`].
pub trait Spectator {}

impl Spectator for span::Comment {}
impl Spectator for span::CharLiteral {}
impl Spectator for span::StringLiteral {}
impl Spectator for word::Whitespace {}
impl Spectator for word::Alphanumeric {}
impl Spectator for word::Operator {}
impl<T> Spectator for Bracket<T> {}

// ----------------------------------------------------------------------------

/// An abbreviation for [`Push<T>`] for all `T` generated by [`WordParser`].
pub trait PushBracket: Default + Flush + Push<Bracket<<Self as Flush>::Output>> {}

/// A [`Parser`] that recognizes nested brackets.
pub struct BracketParser<I: PushBracket> {
    /// The current output stream, which collects the contents of the innermost
    /// bracket.
    inner: I,

    /// Paused output streams, which collect the contents of outer brackets,
    /// ordered from outside to inside.
    stack: Vec<I>,

    /// The opening bracket this `BracketParser` looks for.
    open: char,

    /// The closing bracket this `BracketParser` looks for.
    close: char,
}

impl<I: PushBracket> BracketParser<I> {
    pub fn new(open: char, close: char) -> Self {
        BracketParser {inner: I::default(), stack: Vec::new(), open, close}
    }

    /// Close the current bracket, and set `inner` to `next`.
    fn close(&mut self, mut next: I) {
        next.push(Bracket {
            open: self.open,
            contents: self.inner.flush(),
        });
        self.inner = next;
    }
}

impl<I: PushBracket> Parser for BracketParser<I> {
    fn error(&mut self, error: E) { self.inner.error(error); }
}

impl<I: PushBracket + Push<char>> Push<char> for BracketParser<I> {
    fn push(&mut self, token: char) {
        if token == self.open {
            let mut next = I::default();
            std::mem::swap(&mut next, &mut self.inner);
            self.stack.push(next);
        } else if token == self.close {
            if let Some(next) = self.stack.pop() {
                self.close(next);
            } else {
                self.inner.error(MISSING_OPEN);
            }
        } else {
            self.inner.push(token);
        }
    }
}

impl<T: Spectator, I: Push<T> + PushBracket> Push<T> for BracketParser<I> {
    fn push(&mut self, token: T) { self.inner.push(token); }
}

impl<I: PushBracket> Flush for BracketParser<I> {
    type Output = I::Output;

    fn flush(&mut self) -> Self::Output {
        while let Some(next) = self.stack.pop() {
            self.inner.error(MISSING_CLOSE);
            self.close(next);
        }
        self.inner.flush()
    }
}

// ----------------------------------------------------------------------------

#[cfg(test)]
mod tests {
    use super::*;
}
